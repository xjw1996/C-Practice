#include <stdio.h>
#include <iostream>



//这样能够从很大程度上增加程序的健壮性，防止对空指针进行无意义的操作。
void func(char* p) {
    if (p == NULL) {
        printf("(null)\n");
    }
    else {
        printf("%s\n", p);
    }
}


int main() {

    //*******************
    //     空指针
    //*******************

    char* str = NULL;
    //gets(str);
    //std::cin >> str;
    func(str);
    printf("%s\n", str);

    //*******************
    //     void 指针
    //*******************
    //void* 表示一个有效指针，它确实指向实实在在的数据，只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换。
    //C语言动态内存分配函数 malloc() 的返回值就是void *类型，在使用时要进行强制类型转换
    char* str = (char*)malloc(sizeof(char) * 30);
    return 0;
}

//运行程序后发现，还未等用户输入任何字符，printf() 就直接输出了(null)。我们有理由据此推断，gets() 和 printf() 都对空指针做了特殊处理：
//****gets() 不会让用户输入字符串，也不会向指针指向的内存中写入数据；
//****printf() 不会读取指针指向的内容，只是简单地给出提示，让程序员意识到使用了一个空指针。



//其实，NULL 是在stdio.h中定义的一个宏，它的具体内容为：
//#define NULL ((void *)0)
//
//(void*)0表示把数值 0 强制转换为void * 类型，最外层的()把宏定义的内容括起来，防止发生歧义。从整体上来看，NULL 指向了地址为 0 的内存，而不是前面说的不指向任何数据。
//
//在进程的虚拟地址空间中，最低地址处有一段内存区域被称为保留区，这个区域不存储有效数据，也不能被用户程序访问，将 NULL 指向这块区域很容易检测到违规指针。


//注意，C语言没有规定 NULL 的指向，只是大部分标准库约定成俗地将 NULL 指向 0，所以不要将 NULL 和 0 等同起来，例如下面的写法是不专业的：
//int* p = 0;
//
//而应该坚持写为：
//int* p = NULL;
