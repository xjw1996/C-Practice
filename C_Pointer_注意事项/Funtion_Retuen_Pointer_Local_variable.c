#include <stdio.h>

int* func() {
    int n = 100;
    return &n;
}

int main() {
    int* p = func(), n,m,l;
    n = *p;//现在获取局部变量的值还来的及
    l = *p;
    printf("value n = %d\n", n);
    printf("value n = %d\n", l);

    m = *p;//12行执行了其他函数，内存被覆盖了

    printf("value m = %d\n", m);
    return 0;


    //------输出结果：--------

       /*   value n = 100
            value n = 100
            value m = 15603999   这个就不知道内存指向哪里了  */

    //   *************************************************
    //   ***********指针作为函数的返回值注意点**************
    //   *************************************************
    /*n 是 func() 内部的局部变量，func() 返回了指向 n 的指针，
    根据上面的观点，func() 运行结束后 n 将被销毁，使用* p 应该获取不到 n 的值。
    但是从运行结果来看，我们的推理好像是错误的，
    func() 运行结束后* p 依然可以获取局部变量 n 的值，这个上面的观点不是相悖吗？*/

    /*前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。
    但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，
    弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，
    值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。*/

    /*第一个例子在调用其他函数之前使用* p 抢先获得了 n 的值并将它保存起来，第二个例子显然没有抓住机会，
    有其他函数被调用后才使用* p 获取数据，这个时候已经晚了，内存已经被后来的函数覆盖了，
    而覆盖它的究竟是一份什么样的数据我们无从推断（一般是一个没有意义甚至有些怪异的值）。*/
    
}
